# ユニバースの定義
（頂点全体の個数は最終的には2冪にしたいが，まずは一般に考える）

頂点が n 個でできる 0 を根とする木を表示するユニバースを考える．

各頂点の深さを定め，各頂点の”距離”を同じ深さの頂点で重複がないように1からつける．
各深さでの頂点の距離の最大値をその深さの幅という．

根0 は深さ=0，距離=1

満たすべき条件は
 - 深さの最大値は n-1
 - 辺は深さの差が 1 であるような頂点間にのみ存在
 - 深さ 1 の幅は n-1 であり，深さ k なら n-k

更に同型なグラフを除くために以下の条件を課す．
 - 任意の深さにおいて，ある頂点から1つ深い頂点達への辺の数は，より距離の小さい頂点からのそれの数以下

 すると以下が分かる．

 - すべての深さ k で距離 1 の頂点から1つ深い頂点への辺の数は n-k-1
 - ある深さで頂点の距離が1増えると，1つ深い頂点への辺の数は（存在すれば）2少なくなる．

特に，深さ k (≥1)以上のグラフの様子は n-k にのみによって定まることが分かる．

（例：頂点6個のユニバースでの深さ1以上のグラフと，頂点7個のユニバースでの深さ2以上のグラフと，頂点8個のユニバースでの深さ3以上のグラフと，etc… は一致することが分かる．）

### 脱線
n頂点のときのユニバースの頂点・辺の総数を求めてみる

・頂点

1 + Σ_{1 ≤ m ≤ n-1} n-m = 1+ 1/2*n(n-1)

・辺

 深さ n-k から n-k+1 への辺の総数 a_k (1 ≤ k ≤ n-1) は k=2m-1 or 2mとして

 - a_2m-1 = m^2
 - a_2m = m^2+m

a_n = n-1 と定められるので，ユニバースでの総数はnが偶数なら

n-1 + Σ_{1 ≤ m ≤ n/2 - 2} 2m^2 + m

奇数のときは使わないので考えない．

とにもかくにも，頂点はn^2オーダー，辺はn^3オーダーになることが分かる．


# Graphillopnについて
グラフ（含ユニバース）のタイプは nx.Graph型であり list型ではない．

一般に nx.Graph(list(g)) : （g はリスト等） で変換する．

nx.Graph型はdictのlistだけど，Graphクラス内の関数\_\_iter\_\_によりリスト的な操作（lambda式を用いずにsortなど）が定義されている．

一方で graph[n] は\{頂点nと辺で結ばれている頂点x: \{\} \} というdictで与えられる．

# tag "class化"について
tag class化以降で 互換性なくなった
具体的には5th.pyとかに書いてある．

